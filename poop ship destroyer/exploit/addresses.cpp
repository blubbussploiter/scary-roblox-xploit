
#include "..\output.h"
#include "util/static_addresses.h"
#include "dynamic_addresses.h"

/* cruddy pattern scan POWA! */
/* these patterns might break sometimes :( */

std::map<std::string, std::uintptr_t> RBX::FamilyGuy::dynamic_addresses = std::map<std::string, std::uintptr_t>();
bool RBX::FamilyGuy::luavm_secure_enabled = 0;

uintptr_t* RBX::FamilyGuy::getWaitingScriptsJob()
{
	uintptr_t taskScheduler = getTaskScheduler();
	if (taskScheduler)
	{
		return static_addresses::getJobByName("LuaResumeWaitingScripts", taskScheduler);
	}
	return 0;
}

uintptr_t RBX::FamilyGuy::getScriptContext()
{
	/* what does this do? 
	
		scans through roblox's rtti for scriptcontext's vtable, and finds the active scriptcontext through a ptr to the vtable
		basically; if you know ida's classinformer.. this is kind of like it but.. it just gives you the address straight up.

	*/

	if (!find("scriptcontext"))
	{
		uintptr_t scriptContextVFtable = ida::get_vtable_pointer("ScriptContext@RBX");
		set("scriptcontext",vTableScan((char*)&scriptContextVFtable), 0);
	}

	return get("scriptcontext");
}

uintptr_t RBX::FamilyGuy::getTaskScheduler()
{
	if (!find("taskscheduler"))
	{
		std::uintptr_t taskschedulerSingleton = static_addresses::getTaskSchedulerSingletonAddress();
		if (!taskschedulerSingleton)
		{
			return -2;
		}
		set("taskscheduler", reinterpret_cast<int(__cdecl*)()>(taskschedulerSingleton)(), 0);
	}
	return get("taskscheduler");
}

uintptr_t RBX::FamilyGuy::getLuaState()
{
	/* fetch lua state thru this poopy doopy scary lil pointer call... (only called once.. (i think))*/

	uintptr_t sc = getScriptContext();
	uintptr_t gs = get("getglobalstate");

	if (gs)
	{
		if (sc)
		{
			auto f = reinterpret_cast<uintptr_t(__thiscall*)(uintptr_t, int)>(gs)(sc, 0);
			set("luastate", f, 0);
			return get("luastate");
		}
	}
	else
	{
		return -2;
	}

	return -1;
}

uintptr_t RBX::FamilyGuy::createNewLuaThread()
{
	uintptr_t newthread = get("newthread");
	uintptr_t luaState = getLuaState();

	if (luaState && newthread)
	{
		return reinterpret_cast<int(__cdecl*)(uintptr_t)>(newthread)(luaState);
	}

	return -2;
}

int RBX::FamilyGuy::feedDeserializer(uintptr_t thread, const std::string& code, const char* chunkName, int modKey)
{
	uintptr_t deserializer = get("deserializer");

	if (deserializer && thread)
	{	
		if (luavm_secure_enabled)
		{
			return reinterpret_cast<int(__cdecl*)(uintptr_t, const std::string&, const char*, int)>(deserializer)(thread, code, chunkName, modKey);
		}
		else
		{
			return reinterpret_cast<int(__fastcall*)(uintptr_t, const std::string&, const char*, int)>(deserializer)(thread, code, chunkName, modKey);
		}
	}
	return -2;
}

int RBX::FamilyGuy::feedSpawn(uintptr_t thread)
{
	std::uintptr_t spawn = get("spawn");

	if (spawn && thread)
	{
		return reinterpret_cast<int(__cdecl*)(int)>(spawn)(thread);
	}
	return -2;
}

int RBX::FamilyGuy::scoutAddresses()
{
	/* static addresses only: dynamic ones are defined in their get functions */

	output::printf("Scouting addresses... (this may take a minute)\n");

	findAddress("getglobalstate", static_addresses::getGlobalStateAddress());
	findAddress("deserializer", static_addresses::getDeserializerAddress());

	findAddress("tolstring", static_addresses::lua::getLuaTolstringAddress());
	findAddress("topointer", static_addresses::lua::getLuaTopointerAddress());
	findAddress("setmetatable", static_addresses::lua::getLuaSetMetatableAddress());
	findAddress("settable", static_addresses::lua::getLuaSettableAddress());
	findAddress("gettop", static_addresses::lua::getLuaGettopAddress());
	findAddress("getfield", static_addresses::lua::getLuaGetfieldAddress());
	findAddress("setfield", static_addresses::lua::getLuaSetfieldAddress());
	findAddress("settop", static_addresses::lua::getLuaSettopAddress());
	findAddress("setreadonly", static_addresses::lua::getSetreadonlyAddress());
	findAddress("newthread", static_addresses::lua::getLuaNewThreadAddress());
	findAddress("pcall", static_addresses::lua::getLuaPcallAddress());
	findAddress("pushstring", static_addresses::lua::getLuaPushstringAddress());
	findAddress("pushcclosure", static_addresses::lua::getLuaPushcclosureAddress());
	findAddress("pushvalue", static_addresses::lua::getLuaPushvalueAddress());
	findAddress("spawn", static_addresses::getSpawnAddress());
	findAddress("getmetatable", static_addresses::lua::getLuaGetMetatableAddress());
	findAddress("pushnil", static_addresses::lua::getLuaPushnilOrInsertAddress(0));
	findAddress("insert", static_addresses::lua::getLuaPushnilOrInsertAddress(1));
	findAddress("type", static_addresses::lua::getLuaTypeNameOrTypeAddress(0));
	findAddress("typename", static_addresses::lua::getLuaTypeNameOrTypeAddress(1));

	size_t found = 0;

	for (auto& kv : dynamic_addresses)
	{
		if (kv.second != 0)
		{
			found++;
		}
	}

	if (found != dynamic_addresses.size())
	{
		output::printf("Failed to find all addresses! got [%d/%d]\n", found, dynamic_addresses.size());
		return 0;
	}

	output::printf("Done scouting addresses!\n");
	return 1;
}

void RBX::FamilyGuy::findAddress(std::string addrName, uintptr_t address)
{
	set(addrName, address);
	if (address)
	{
		bool retcheckd = hasRetcheck(address);
		luavm_secure_enabled = retcheckd; /* if any function's retchecked.. that means the client has LUAVM_SECURE enabled! UHO H!!! */
		output::printf("[%s] = 0x%08X, r? = %d\n", addrName.c_str(), prettify(address), retcheckd);
	}
	else
	{
		output::printf("[scout_err]: failed to find %s\n", addrName.c_str());
	}
}

bool RBX::FamilyGuy::hasRetcheck(uintptr_t addr)
{
	return retcheck::unprotect((BYTE*)addr) != addr;
}
