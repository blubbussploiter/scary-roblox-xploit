
#pragma once

/* State grabbing header */

#include <map>
#include <cstdint>

#include "util/memory.h"
#include "addresses.h"

namespace RBX {

	class FamilyGuy
	{
	private:

		static std::map<std::string, std::uintptr_t> dynamic_addresses;

		static bool find(std::string addressName)
		{
			return dynamic_addresses.count(addressName) != 0;
		}

		static void set(std::string addressName, std::uintptr_t address, bool checkForRetcheck=true)
		{
			if (checkForRetcheck && address && hasRetcheck(address))
			{
				address = retcheckBypass(address);
			}
			dynamic_addresses[addressName] = address;
		}

		static std::uintptr_t get(std::string addressName)
		{
			if (find(addressName))
			{
				return dynamic_addresses.at(addressName);
			}
			return 0;
		}

	public:

		static bool luavm_secure_enabled;

		static uintptr_t getScriptContext();
		static uintptr_t* getWaitingScriptsJob();
		static uintptr_t getTaskScheduler();
		static uintptr_t getLuaState();
		static uintptr_t createNewLuaThread();

		static int scoutAddresses();
		static void findAddress(std::string addrName, uintptr_t address);
		static bool hasRetcheck(uintptr_t addr);

		static uintptr_t getAddress(std::string name)
		{
			return get(name);
		}

		class lua
		{
		public:
			static int pushnil(uintptr_t thread);
			static int pushstring(uintptr_t thread, std::string string);
			static int pushvalue(uintptr_t thread, int index);
			static int insert(uintptr_t thread, int index);
			static std::string tolstring(uintptr_t thread, int index);
			static void* topointer(uintptr_t thread, int index);
			static int type(uintptr_t thread, int index);
			static int ttypename(uintptr_t thread, int type);
			static int pushcclosure(uintptr_t thread, int closure, int nupval);
			static int pcall(uintptr_t thread, int nargs, int nresults, int nerrfunc);
			static int gettop(uintptr_t thread);
			static int getfield(uintptr_t thread, int index, std::string field);
			static int setfield(uintptr_t thread, int index, std::string field);
			static int setmetatable(uintptr_t thread, int index);
			static int getmetatable(uintptr_t thread, int index);
			static int setreadonly(uintptr_t thread, int index, bool readonly);
			static int settop(uintptr_t thread, int index);
		};

		static int feedDeserializer(uintptr_t thread, const std::string& string, const char* chunkName, int modKey);
		static int feedSpawn(uintptr_t thread);


	};

}