#pragma once

#include <sstream>
#include <vector>
#include <cstdint>
#include <iomanip>

#include "memory.h"
#include <set>

namespace ida
{
    typedef unsigned char byte;

    static std::string bytes_to_ida_pattern(byte* bytes, int32_t size)
    {
        std::stringstream ida_pattern;
        ida_pattern << std::hex << std::setfill('0');
        for (size_t i = 0; i < size; i++)
        {
            const int32_t current_byte = bytes[i];
            if (current_byte != 255)
                ida_pattern << std::setw(2) << current_byte;
            else
                ida_pattern << std::setw(1) << "?";

            if (i != size - 1)
                ida_pattern << " ";
        }

        return ida_pattern.str();
    }

    static std::vector<uintptr_t> get_xrefs_to(uintptr_t address, uintptr_t start, uintptr_t size)
    {
        std::vector<uintptr_t> xrefs = {};

        // Convert the address over to an IDA pattern string
        const std::string ida_pattern = bytes_to_ida_pattern((byte*)&address, 4);

        // Get the end of the section (in our case the end of the .rdata section)
        const uintptr_t end = start + size;

        while (start && start < end)
        {
            uintptr_t xref = (uintptr_t)util::idaPatternScanner(start, ida_pattern.c_str(), size);

            // If the xref is 0 it means that there either were no xrefs, or there are no remaining xrefs.
            // So we should break out of our loop, otherwise it will keep on trying to look for xrefs.
            if (!xref)
                break;

            // We've found an xref, save it in the vector, and add 4 to start, so it wil now search for xrefs
            // from the previously found xref untill we're at the end of the section, or there aren't any xrefs left.
            xrefs.push_back(xref);
            start = xref + 4;
        }

        return xrefs;
    }

    static bool get_section_info(uintptr_t base_address, const std::string& section_name, uintptr_t& section_start, uintptr_t& section_size)
    {
        const PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)base_address;
        if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
            return false;

        const PIMAGE_NT_HEADERS32 nt_headers = (PIMAGE_NT_HEADERS32)(base_address + dos_header->e_lfanew);
        if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
            return false;

        PIMAGE_SECTION_HEADER section_header = IMAGE_FIRST_SECTION(nt_headers);
        uint16_t number_of_sections = nt_headers->FileHeader.NumberOfSections;
        while (number_of_sections > 0)
        {
            // If we're at the right section
            if (!strcmp(section_name.c_str(), (const char*)section_header->Name))
            {
                section_start = base_address + section_header->VirtualAddress;
                section_size = section_header->SizeOfRawData;
                return true;
            }

            section_header++;
            number_of_sections--;
        }

        return false;
    }

    static uintptr_t get_vtable_pointer(const std::string& table_name)
    {
        uintptr_t base_address = (uintptr_t)GetModuleHandleA(0);
        if (!base_address)
            return 0;

        // Type descriptor names look like this: .?AVC_CSPlayer@@ (so: ".?AV" + table_name + "@@")
        const std::string type_descriptor_name = ".?AV" + table_name + "@@";

        // Convert the string to an IDA pattern so that we can pattern scan it
        std::string ida_pattern = bytes_to_ida_pattern((byte*)type_descriptor_name.data(), type_descriptor_name.size());

        uintptr_t rtti_type_descriptor = (uintptr_t)util::idaPatternScanner(ida_pattern.data());
        if (!rtti_type_descriptor)
        {
            return 0;
        }
        // We're doing - 0x8 here, because the location of the rtti_type_descriptor is 0x8 bytes before the string (open up client_panorama.dll in IDA and take a look) 
        rtti_type_descriptor -= 0x8;

        // We only need to get xrefs that are inside the .rdata section (there sometimes are xrefs in .text, so we have to filter them out)
        uintptr_t rdata_start = 0, rdata_size = 0;
        if (!get_section_info(base_address, ".rdata", rdata_start, rdata_size))
        {
            return 0;
        }

        // Get all xrefs to the type_descriptor
        const std::vector<uintptr_t> xrefs = get_xrefs_to(rtti_type_descriptor, rdata_start, rdata_size);
        for (const uintptr_t xref : xrefs)
        {
            // xref - 0x8 = offset of this vtable in complete class (from top)
            // So if it's 0 it means it's the class we need, and not some class it inherits from (again, opening up client_panorama.dll in IDA will help you understand)
            const int32_t offset_from_class = *(int32_t*)(xref - 0x8);

            if (offset_from_class != 0)
                continue;

            // We've found the correct xref, the object locator is 0xC bytes before the xref. (Again, client_panorama.dll yada yada yada)
            const uintptr_t object_locator = xref - 0xC;

            // Now we need to get an xref to the object locator, as that's where the vtable is located
            {
                // Convert the object locator address to an IDA pattern
                ida_pattern = bytes_to_ida_pattern((byte*)&object_locator, 4);

                const uintptr_t vtable_address = (uintptr_t)util::idaPatternScanner(rdata_start, ida_pattern.data(), rdata_size) + 0x4;

                // Here I'm checking for <= 4 as we're adding 0x4 to it. So if the pattern scan returns 0 we still head the fuck out
                if (vtable_address <= 4)
                    return 0;

                return vtable_address;

            }
        }

        // We for some odd reason didn't find any valid xrefs
        return 0;
    }

    // my stuff 

    static size_t read_string_size(uintptr_t address)
    {
        size_t s = 0;
        for (int i = 0; i < 512; i++)
        {
            unsigned char c = *reinterpret_cast<unsigned char*>(address + i);
            if (c != 0x00)
            {
                s++;
            }
            else break;
        }
        return s;
    }

    static uintptr_t find_ref_to_offset(uintptr_t offset, uintptr_t start, uintptr_t size)
    {
        for (uint32_t i = 0; i < size; i++)
        {
            uintptr_t addr = start + i;
            unsigned char c = *reinterpret_cast<unsigned char*>(addr);

            /* if at address is a push instruction, and the pushed offset is our offset return the address! (ezpz) */
            if (c == 0x68)
            {
                unsigned int pushedOffset = *reinterpret_cast<unsigned int*>(addr + 1);
                if (pushedOffset == offset)
                {
                    return addr;
                }
            }

            /* if at address is a mov instruction, and the pushed offset is our offset return the address! (ezpz) */
            if (c == 0xC7)
            {
                unsigned int pushedOffset = *reinterpret_cast<unsigned int*>(addr + 3);
                if (pushedOffset == offset)
                {
                    return addr;
                }
            }

        }
        return 0;
    }

    static std::vector<uintptr_t> find_refs_to_offset(uintptr_t offset, uintptr_t start, uintptr_t size)
    {
        auto refs = std::vector<uintptr_t>();
        for (uint32_t i = 0; i < size; i++)
        {
            uintptr_t addr = start + i;
            unsigned char c = *reinterpret_cast<unsigned char*>(addr);

            /* if at address is a push instruction, and the pushed offset is our offset return the address! (ezpz) */
            if (c == 0x68)
            {
                unsigned int pushedOffset = *reinterpret_cast<unsigned int*>(addr + 1);
                if (pushedOffset == offset)
                {
                    refs.push_back(addr);
                }
            }
        }
        return refs;
    }

    static uintptr_t find_pushed_offset(uintptr_t addr)
    {
        unsigned char c = *reinterpret_cast<unsigned char*>(addr);

        /* if at address is a push instruction, return the pushed offset */
        if (c == 0x68)
        {
            unsigned int pushedOffset = *reinterpret_cast<unsigned int*>(addr + 1);
            return pushedOffset;
        }
        return 0;
    }

    static uintptr_t find_called_function(uintptr_t addr)
    {
        unsigned char c = *reinterpret_cast<unsigned char*>(addr);

        /* if at address is a push instruction, return the pushed offset */
        if (c == 0xE8)
        {
            unsigned int off = *reinterpret_cast<unsigned int*>(addr + 1);
            return addr + 5 + off;
        }
        return 0;
    }

    static std::vector<uintptr_t> find_farthest(uintptr_t addr, uintptr_t(*searchCallback)(uintptr_t))
    {
        std::vector<uintptr_t> addresses;
        for (int i = 1; i < 1024; i++)
        {
            if (searchCallback(addr - i) != 0)
            {
                addresses.push_back(searchCallback(addr - i));
            }
        }
        return addresses;
    }

    static std::vector<uintptr_t> find_nearest(uintptr_t addr, uintptr_t(*searchCallback)(uintptr_t))
    {
        std::vector<uintptr_t> addresses;
        for (int i = 1; i < 1024; i++)
        {
            if (searchCallback(addr + i) != 0)
            {
                addresses.push_back(searchCallback(addr + i));
            }
        }
        return addresses;
    }

    static uintptr_t find_farthest_pushed_offset(uintptr_t addr, size_t index)
    {
        auto offsets = ida::find_farthest(addr, ida::find_pushed_offset);
        if (offsets.size() >= index + 1)
        {
            return offsets.at(index);
        }
        return 0;
    }

    static uintptr_t find_nearest_pushed_offset(uintptr_t addr, size_t index)
    {
        auto offsets = ida::find_nearest(addr, ida::find_pushed_offset);
        if (offsets.size() >= index + 1)
        {
            return offsets.at(index);
        }
        return 0;
    }

    static uintptr_t find_farthest_called_function(uintptr_t addr, size_t index)
    {
        auto offsets = ida::find_farthest(addr, ida::find_called_function);
        if (offsets.size() >= index + 1)
        {
            return offsets.at(index);
        }
        return 0;
    }

    static uintptr_t find_nearest_called_function(uintptr_t addr, int index)
    {
        auto offsets = ida::find_nearest(addr, ida::find_called_function);
        if (offsets.size() >= index + 1)
        {
            return offsets.at(index);
        }
        return 0;
    }

    static uintptr_t get_function_start(uintptr_t innerAddr)
    {
        for (int i = 0; i < 1024; i++)
        {
            unsigned char c = *reinterpret_cast<unsigned char*>(innerAddr - i);
            unsigned char n = *reinterpret_cast<unsigned char*>(innerAddr - i-1);
            if (c == 0x55 && n == 0xCC)
            {
                return innerAddr - i;
            }
        }
        return 0;
    }

    static uintptr_t get_string_address(const std::string& referencedString, bool matchLength=0)
    {
        // Convert the string to an IDA pattern so that we can pattern scan it

        std::string ida_pattern = bytes_to_ida_pattern((byte*)referencedString.data(), referencedString.size());
        auto possibleStringPatterns = util::multi_idaPatternScanner(ida_pattern.data());

        if (!matchLength)
        {
            if(!possibleStringPatterns.empty())
            {
                return possibleStringPatterns.at(0);
            }
        }
        else
        {
            for (int i = 0; i < possibleStringPatterns.size(); i++)
            {
                uintptr_t possibleStringAddress = possibleStringPatterns[i];
                if (possibleStringAddress)
                {
                    /* read size, compare it to our referencedString's size */
                    size_t size = read_string_size(possibleStringAddress);
                    if (size == referencedString.size())
                    {
                        return possibleStringAddress;
                    }
                }
            }
        }

        return 0;
    }


    /* arithmetic stuff */

    static uintptr_t find_mov_offset_offset(uintptr_t addr, int arg)
    {

        unsigned char c = *reinterpret_cast<unsigned char*>(addr);

        /* if at address is a mov instruction, return the first or second moved offset */
        if (c == 0xC7)
        {
            switch (arg)
            {
            case 0:
            {
                unsigned int pushedOffset = *reinterpret_cast<unsigned int*>(addr + 2);
                return pushedOffset;
            }
            case 1:
            {
                unsigned int pushedOffset = *reinterpret_cast<unsigned int*>(addr + 6);
                return pushedOffset;
            }
            }
        }
        return 0;
    }

    /* since mov instructions are pretty ambiguous.. (pushing offsets or just pushing registers, we use this instead) */

    static uintptr_t is_mov_instruction(uintptr_t addr)
    {
        unsigned char c = *reinterpret_cast<unsigned char*>(addr);

        /* if at address is a mov instruction, return the addr of it */
        if (c == 0xC7)
        {
            return addr;
        }

        return 0;
    }

    static uintptr_t get_or_offset_offset(uintptr_t addr)
    {
        unsigned char c = *reinterpret_cast<unsigned char*>(addr);

        if (c == 0x81)
        {
            return *(uintptr_t*)(addr + 2);
        }

        return 0;
    }

    static uintptr_t get_or_offset_operand(uintptr_t orAddr)
    {
        unsigned char c = *reinterpret_cast<unsigned char*>(orAddr);

        if (c == 0x81)
        {
            return *(uintptr_t*)(orAddr + 6);
        }

        return 0;
    }

}
