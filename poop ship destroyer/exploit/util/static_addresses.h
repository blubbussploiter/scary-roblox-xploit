#pragma once

#include "ida.h"
#include "../addresses.h"

/* my own stuff */
/* okay guys dont make fun of me for this cxode */

namespace static_addresses
{
    static uintptr_t getLuaVM_loadAddress();

    namespace lua
    {

        static uintptr_t getLuaTypeNameOrTypeAddress(bool t)
        {

            uintptr_t string = ida::get_string_address("invalid value (%s) at index %d in table");

            if (!string)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(string, text_start, text_size);
            if (ref)
            {
                if (t)
                {

                    return ida::find_farthest_called_function(ref, 0);
                }
                else
                {
                    return ida::find_farthest_called_function(ref, 1);
                }
            }

            return 0;
        }

        static uintptr_t getLuaGettopAddress()
        {

            uintptr_t tostring = ida::get_string_address("tostring", 1);

            if (!tostring)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(tostring, text_start, text_size);
            if (ref)
            {
                return ida::find_farthest_called_function(ref, 0);
            }
            return 0;
        }

        static uintptr_t getLuaSettopAddress()
        {
            uintptr_t themtislocked = ida::get_string_address("The metatable is locked", 1);

            if (!themtislocked)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(themtislocked, text_start, text_size);
            if (ref)
            {
                return ida::find_called_function(ref + 0x1B);
            }
            return 0;
        }
        
        static uintptr_t getLuaPcallAddress()
        {
            uintptr_t valuenotFound = ida::get_string_address("*** Value not found ***", 1);

            if (!valuenotFound)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(valuenotFound, text_start, text_size);
            return ida::find_called_function(ref - 0x10);
        }

        static uintptr_t getLuaPushstringAddress()
        {
            uintptr_t themtislocked = ida::get_string_address("The metatable is locked", 1);

            if (!themtislocked)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(themtislocked, text_start, text_size);
            if (ref)
            {
                return ida::find_called_function(ref + 0x6);
            }
            return 0;
        }

        static uintptr_t getLuaPushvalueAddress()
        {
            uintptr_t tostring = ida::get_string_address("tostring");

            if (!tostring)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(tostring, text_start, text_size);
            if (ref)
            {
                return ida::find_nearest_called_function(ref, 2);
            }
            return 0;
        }

        static uintptr_t getLuaNewThreadAddress()
        {
            uintptr_t luaFuncExpected = ida::get_string_address("Lua function expected", 1);

            if (!luaFuncExpected)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(luaFuncExpected, text_start, text_size);
            if(ref)
            {
                return ida::find_farthest_called_function(ref, 2);
            }
            return ref;
        }

        static uintptr_t getLuaGetfieldAddress()
        {
            uintptr_t tostring = ida::get_string_address("tostring", 1);

            if (!tostring)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(tostring, text_start, text_size);
            if (ref)
            {
                return ida::find_nearest_called_function(ref, 0);
            }
            return 0;
        }

        static uintptr_t getLuaTopointerAddress()
        {
            uintptr_t string = ida::get_string_address("%s: %p", 1);

            if (string)
            {

                uintptr_t text_start = 0, text_size = 0;
                if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
                {
                    return 0;
                }

                uintptr_t ref = ida::find_ref_to_offset(string, text_start, text_size);
                if (ref)
                {
                    uintptr_t call = ida::find_farthest_called_function(ref, 2);
                    return call;
                }

            }

            return 0;
        }

        /* second method of getting it */
        static uintptr_t getSetreadonlyAddress2()
        {
            uintptr_t string = ida::get_string_address("noise", 1);

            if (string)
            {

                uintptr_t text_start = 0, text_size = 0;
                if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
                {
                    return 0;
                }

                uintptr_t ref = ida::find_ref_to_offset(string, text_start, text_size);

                if (ref)
                {
                    return ida::find_nearest_called_function(ref, 1);
                }

            }

            return 0;
        }

        static uintptr_t getSetreadonlyAddress()
        {
            uintptr_t string = ida::get_string_address("count == (func == luaopen_base) ? 2 : 1 file: ");

            if (string)
            {

                uintptr_t text_start = 0, text_size = 0;
                if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
                {
                    return 0;
                }

                uintptr_t ref = ida::find_ref_to_offset(string, text_start, text_size);

                if (ref)
                {
                    uintptr_t call = ida::find_nearest_called_function(ref, 1);
                    return call;
                }

            }
            else
            {
                return getSetreadonlyAddress2();
            }

            return 0;
        }

        static uintptr_t getLuaTolstringAddress()
        {
            uintptr_t luaExceptionVtable = ida::get_vtable_pointer("lua_exception");
            if (luaExceptionVtable)
            {
                uintptr_t except_throwAddr = *(uintptr_t*)(luaExceptionVtable + 0x4);
                if (except_throwAddr)
                {
                    uintptr_t tolstring = ida::find_nearest_called_function(except_throwAddr, 0);
                    return tolstring;
                }
            }
            return 0;
        }

        static uintptr_t getLuaGetMetatableAddress()
        {
            uintptr_t __mt = ida::get_string_address("__metatable", 1);

            if (!__mt)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            auto refs = ida::find_refs_to_offset(__mt, text_start, text_size);
            if (!refs.empty())
            {
                uintptr_t last = refs.at(refs.size()-2);
                if (last)
                {
                    return ida::find_farthest_called_function(last, 1);
                }
            }

            return 0;
        }

        static uintptr_t getLuaSetMetatableAddress()
        {
            uintptr_t attemptToModify = ida::get_string_address("cannot change a protected metatable", 1);

            if (!attemptToModify)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(attemptToModify, text_start, text_size);
            if (ref)
            {
                return ida::find_nearest_called_function(ref, 2);
            }
            return 0;
        }

        static uintptr_t getLuaSettableAddress()
        {
            uintptr_t attemptToModify = ida::get_string_address("Attempt to modify a readonly table", 1);

            if (!attemptToModify)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_refs_to_offset(attemptToModify, text_start, text_size)[0];           
            if (ref)
            {
                return ida::get_function_start(ref);
            }
            return 0;
        }

        static uintptr_t getLuaSetfieldAddress()
        {
            uintptr_t spawn = ida::get_string_address("Spawn", 1);

            if (!spawn)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(spawn, text_start, text_size);
            if (ref)
            {
                return ida::find_nearest_called_function(ref, 0);
            }
            return 0;
        }

        static uintptr_t getLuaPushnilOrInsertAddress(bool pushnilOrInsert)
        {
            uintptr_t loadstringNotAvail = ida::get_string_address("loadstring() is not available");

            if (!loadstringNotAvail)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(loadstringNotAvail, text_start, text_size);
            uintptr_t loadVM = getLuaVM_loadAddress();
            
            if (ref)
            {
                for (int i = 0; i < 256; i++)
                {
                    ida::byte b = *(ida::byte*)(ref + i);
                    if (b && b == 0xE8)
                    {
                        uintptr_t call = ida::find_called_function(ref + i);
                        if (call == loadVM)
                        {
                            switch (pushnilOrInsert)
                            {
                            case false:
                            {
                                return ida::find_nearest_called_function(ref + i, 0);
                            }
                            case true:
                            {
                                return ida::find_nearest_called_function(ref + i, 1);
                            }
                            }
                        }
                    }
                }
            }

            return 0;
        }

        static uintptr_t getLuaPushcclosureAddress()
        {
            uintptr_t crash = ida::get_string_address("crash__", 1);

            if (!crash)
            {
                return 0;
            }

            uintptr_t text_start = 0, text_size = 0;
            if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
            {
                return 0;
            }

            uintptr_t ref = ida::find_ref_to_offset(crash, text_start, text_size);
            if (ref)
            {
                return ida::find_farthest_called_function(ref, 0);
            }
            return 0;
        }

    }

    static uintptr_t getSandboxThreadAddress()
    {
        uintptr_t getThreadIdenThreadEqIden = ida::get_string_address("getThreadIdentity(thread)==identity");

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(getThreadIdenThreadEqIden, text_start, text_size);

        if (ref)
        {
            return ida::get_function_start(ref);
        }
        return 0;
    }

    static uintptr_t getSpawnAddress()
    {
        uintptr_t spawn = ida::get_string_address("Spawn", 1);

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(spawn, text_start, text_size);
        if(ref)
        {
            return ida::find_farthest_pushed_offset(ref, 0);
        }
        return 0;
    }

    static uintptr_t getTaskSchedulerSingletonAddress()
    {
        /* taskschedulers singleton is called thru here so like get it or soemthing */
        uintptr_t threadAffinityString = ida::get_string_address("ThreadAffinity", 1);

        /* we search for the function that references our string through text */

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(threadAffinityString, text_start, text_size);
        uintptr_t __taskscheduler0 = ida::find_farthest_pushed_offset(ref, 1); /* account for pushed 'diagnostic' string before push of our string + push of our string */

        if (__taskscheduler0)
        {
            /* reading a function's memory can be super duper useful for finding offsets and things like that... keep that in mind! */
            return ida::find_called_function(__taskscheduler0);
        }
        return 0;
    }

    static uintptr_t getGlobalStateAddress()
    {
        uintptr_t vm_index = ida::get_string_address("globalStates[vm_index]");

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(vm_index, text_start, text_size);
        if (ref)
        {
            return ida::get_function_start(ref);
        }

        return 0;
    }

    static uintptr_t getLuaVM_loadAddress()
    {

        uintptr_t oldResultModuleRef = ida::get_string_address("oldResult, moduleRef  = ");

        /* we search for the function that references our string through text */

        if (!oldResultModuleRef)
        {
            return 0;
        }

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(oldResultModuleRef, text_start, text_size);
        if (ref)
        {
            uintptr_t landMark = 0;
            for (int i = 1; i < 64; i++)
            {
                ida::byte b = *(ida::byte*)(ref + i);
                if (b == 0x68)
                {
                    landMark = ref + i;
                }
            }
            if (landMark)
            {
                return ida::find_nearest_called_function(landMark, 0);
            }
        }
        return 0;
    }

    static uintptr_t getDeserializerAddress()
    {
        uintptr_t vmLoad = getLuaVM_loadAddress();
        if (vmLoad)
        {
            /* next call is deserializer */
            for (int i = 0; i < 256; i++)
            {
                ida::byte b = *(ida::byte*)(vmLoad + i);
                if (b && b == 0xE8)
                     return ida::find_called_function(vmLoad + i);
            }
        }

        return 0;
    }

    static uintptr_t getWaitingScriptsJobStepAddress()
    {
        uintptr_t string = ida::get_string_address("Waiting scripts start, data model: %p");

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(string, text_start, text_size);
        if (ref)
        {
            uintptr_t func = ida::get_function_start(ref);
            return func;
        }

        return 0;
    }

    static uintptr_t getGetJobsByNameAddress()
    {

        /* string used in the definition of this function in reflection */

        uintptr_t getJobTimePeakFractionString = ida::get_string_address("GetJobTimePeakFraction", 1);
        uintptr_t taskSchedulerSingletonAddress = getTaskSchedulerSingletonAddress(); /* searched for through calls in the function found by the string above */

        /* we search for the function that references our string through text */

        uintptr_t text_start = 0, text_size = 0;
        if (!ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            return 0;
        }

        uintptr_t ref = ida::find_ref_to_offset(getJobTimePeakFractionString, text_start, text_size);
        uintptr_t __getJobTimePeakFraction = ida::find_nearest_pushed_offset(ref, 0);

        for (int i = 0; i < 512; i++)
        {
            unsigned char b = *(unsigned char*)(__getJobTimePeakFraction + i);
            if (b == 0xE8)
            {
                unsigned int calledFunc = ida::find_called_function(__getJobTimePeakFraction + i);
                if (calledFunc == taskSchedulerSingletonAddress)
                {
                    /* assembly looks like this:

                              call    taskscheduler_singleton
                              mov     ecx, eax ;; accounted 7 spaces
                              call    get_jobs_by_name
                    */
                    return ida::find_nearest_called_function(__getJobTimePeakFraction + i, 0);
                }
            }
        }

        return 0;
    }

    static uintptr_t* getJobByName(const std::string& jobName, uintptr_t taskScheduler)
    {
        std::vector<uintptr_t*> jobs;
        uintptr_t getJobsByName = getGetJobsByNameAddress();

        if (getJobsByName && taskScheduler)
        {
            /* call getJobsByName */
            reinterpret_cast<void(__thiscall*)(uintptr_t, const std::string&, std::vector<uintptr_t*>&)>(getJobsByName)(taskScheduler, jobName, jobs);

            if (jobs.size() > 0)
            {
                return jobs.at(0);
            }
        }

        return 0;
    }

    namespace nested
    {
        static void setThreadIdentity(uintptr_t thread, int identity)
        {
            uintptr_t setThreadIdentityAndSandboxAddr = getSandboxThreadAddress();

            if (setThreadIdentityAndSandboxAddr)
            {
                output::printf("setThreadIdentity() setting currentThreadIdentity to %d...\n", identity);
                auto setThreadIdentityAndSandbox = reinterpret_cast<int(__cdecl*)(int, int, int, int)>(setThreadIdentityAndSandboxAddr);
                setThreadIdentityAndSandbox(thread, identity, 0, 0);
            }
            else
            {
                output::printf("[error]: Failed to call setThreadIdentityAndSandbox! Thread identity is limited!\n");
            }
        }
    }
}