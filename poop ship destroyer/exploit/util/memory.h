#pragma once

#include <cstdint>
#include <vector>

#include <windows.h>
#include <Psapi.h>

static bool Compare(const char* pData, const char* bMask, const char* szMask)
{
    while (*szMask) {
        if (*szMask != '?') {
            if (*pData != *bMask) return 0;
        }
        ++szMask, ++pData, ++bMask;
    }
    return 1;
}

static uintptr_t vTableScan(const char* vtable, const char* szMask="xxxx")
{
    MEMORY_BASIC_INFORMATION MBI = { 0 };
    SYSTEM_INFO SI = { 0 };
    GetSystemInfo(&SI);
    uintptr_t Start = (uintptr_t)SI.lpMinimumApplicationAddress;
    uintptr_t End = (uintptr_t)SI.lpMaximumApplicationAddress;

    do
    {
        while (VirtualQuery((void*)Start, &MBI, sizeof(MBI))) {
            if ((MBI.Protect & PAGE_READWRITE) && !(MBI.Protect & PAGE_GUARD))
            {
                for (uintptr_t i = (uintptr_t)(MBI.BaseAddress); i - (uintptr_t)(MBI.BaseAddress) < MBI.RegionSize; ++i)
                {
                    if (Compare((const char*)i, vtable, szMask))
                        return i;
                }
            }
            Start += MBI.RegionSize;
        }
    } while (Start < End);
    return 0;
}

namespace util
{
    static MODULEINFO GetModuleInfo()
    {
        const HMODULE hModule = GetModuleHandleW(0);
        MODULEINFO info;

        if (hModule != 0)
        {
            K32GetModuleInformation(GetCurrentProcess(), hModule, &info, sizeof(MODULEINFO));
        }
        return info;
    }

    static auto pattern_to_byte = [](const char* pattern)
    {
            auto bytes = std::vector<char>{};
            auto start = const_cast<char*>(pattern);
            auto end = const_cast<char*>(pattern) + strlen(pattern);

            for (auto current = start; current < end; ++current)
            {
                if (*current == '?')
                {
                    ++current;
                    if (*current == '?')
                        ++current;
                    bytes.push_back('\?');
                }
                else
                {
                    bytes.push_back(strtoul(current, &current, 16));
                }
            }
            return bytes;
    };

    static uint32_t idaPatternScanner(uint32_t base, const char* signature, uint32_t sizeOfImage)
    {
        auto patternBytes = pattern_to_byte(signature);

        uint32_t patternLength = patternBytes.size();
        auto data = patternBytes.data();

        for (uint32_t i = 0; i < sizeOfImage - patternLength; i++)
        {
            bool found = true;
            for (uint32_t j = 0; j < patternLength; j++)
            {
                char a = '\?';
                char b = *(char*)(base + i + j);
                found &= data[j] == a || data[j] == b;
            }
            if (found)
            {
                return base + i;
            }
        }
        return NULL;
    }

    static uint32_t idaPatternScanner(const char* signature)
    {
        MODULEINFO mInfo = GetModuleInfo();
        uint32_t base = (uint32_t)mInfo.lpBaseOfDll;
        uint32_t sizeOfImage = (uint32_t)mInfo.SizeOfImage;
        auto patternBytes = pattern_to_byte(signature);

        uint32_t patternLength = patternBytes.size();
        auto data = patternBytes.data();

        for (uint32_t i = 0; i < sizeOfImage - patternLength; i++)
        {
            bool found = true;
            for (uint32_t j = 0; j < patternLength; j++)
            {
                char a = '\?';
                char b = *(char*)(base + i + j);
                found &= data[j] == a || data[j] == b;
            }
            if (found)
            {
                return base + i;
            }
        }
        return NULL;
    }


    static std::vector<uint32_t> multi_idaPatternScanner(const char* signature)
    {
        MODULEINFO mInfo = GetModuleInfo();
        uint32_t base = (uint32_t)mInfo.lpBaseOfDll;
        uint32_t sizeOfImage = (uint32_t)mInfo.SizeOfImage;

        auto array = std::vector<uint32_t>();
        auto patternBytes = pattern_to_byte(signature);

        uint32_t patternLength = patternBytes.size();
        auto data = patternBytes.data();

        for (uint32_t i = 0; i < sizeOfImage - patternLength; i++)
        {
            bool found = true;
            for (uint32_t j = 0; j < patternLength; j++)
            {
                char a = '\?';
                char b = *(char*)(base + i + j);
                found &= data[j] == a || data[j] == b;
            }
            if (found)
            {
                array.push_back(base + i);
            }
        }
        return array;
    }
}