#pragma once

#include "util/static_addresses.h"
#include "../output.h"

static uintptr_t hate = 0, simpleToken = 0;

static bool findExploitDetectionFFlagsAddresses(uintptr_t& hateFFlag, uintptr_t& simpleToken)
{

    uintptr_t clearAllChildren;
	uintptr_t clearAllChildrenString = ida::get_string_address("ClearAllChildren");

    if (clearAllChildrenString)
    {

        uintptr_t text_start = 0, text_size = 0;
        if (ida::get_section_info((uintptr_t)GetModuleHandle(0), ".text", text_start, text_size))
        {
            uintptr_t ref = ida::find_ref_to_offset(clearAllChildrenString, text_start, text_size);
            auto movs = ida::find_nearest(ref, ida::is_mov_instruction);

            if (movs.size() > 2)
            {
                uintptr_t clearAllChildrenMov = movs.at(2);
                clearAllChildren = ida::find_mov_offset_offset(clearAllChildrenMov, 1);

            }
        }

    }

    if (clearAllChildren)
    {

        for (int i = 0; i < 128; i++)
        {
            uintptr_t possibleOr = clearAllChildren + i;
            ida::byte b = *(ida::byte*)(possibleOr);
            if(b == 0x81) /* if its an or instruction (WITH OFFSET) */
            {
                uintptr_t operand = ida::get_or_offset_operand(possibleOr);
                if (operand == 0x2000) /* this is the HATE_DESTROYALL flag, if it's called this is our OR! */
                {
                    /* a clever client creator could easily swap these, rendering this completely useless! (or not..) */
                    if (!hateFFlag) /* first */
                    {
                        hateFFlag = ida::get_or_offset_offset(possibleOr);
                        continue;
                    }
                    if (!simpleToken) /* second */
                    {
                        simpleToken = ida::get_or_offset_offset(possibleOr);
                    }
                }
            }
        }

    }

    return (hateFFlag && simpleToken);
}

static void destroyFFlags()
{

    if (!hate || !simpleToken)
    {
        findExploitDetectionFFlagsAddresses(hate, simpleToken);
    }

    /* test */

    *(int*)(hate) = 0x0;
    *(int*)(simpleToken) = 0x0;
}