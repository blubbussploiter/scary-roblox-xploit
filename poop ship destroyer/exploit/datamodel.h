
#pragma once

#include <cstdint>

#include "..\output.h"

#include "util/ida.h"
#include "util/static_addresses.h"

#include "execution.h"
#include "communication.h"

#include "dynamic_addresses.h"
#include "datamodelFunctions.h"

static uintptr_t oldStep = 0;
static uintptr_t datamodel = 0;

static bool r;

static int __fastcall newStep(double* _this, uintptr_t stats)
{
	if (!r) /* tell console we have successfully hooked this function! */
	{
		output::printf("detourDatamodelJobStep() detoured!\n");
		r = 1;
	}

	if(!ExploitHandler::get()->scripts.empty())
	{
		std::string front = ExploitHandler::get()->scripts.front();
		ExploitHandler::get()->scripts.pop();

		uintptr_t thread = RBX::FamilyGuy::createNewLuaThread();

		if (thread && thread != -2)
		{
			RBX::Execution::get()->executeScriptInThread(thread, front);
		}
		else
		{
			output::printf("failed to create new thread!\n");
		}

	}

	return reinterpret_cast<int(__thiscall*)(double*, uintptr_t)>(oldStep)(_this, stats);
}

static int newIndex(uintptr_t luaState)
{
	std::string index = RBX::FamilyGuy::lua::tolstring(luaState, 2);

	if (index == "HttpGet")
	{
		RBX::FamilyGuy::lua::pushcclosure(luaState, (int)dataModel_httpGet, 0);
		return 1;
	}

	if (index == "get" || index == "GetObjects")
	{
		RBX::FamilyGuy::lua::pushcclosure(luaState, (int)dataModel_getObjects, 0);
		return 1;
	}

	/* call old index */

	RBX::FamilyGuy::lua::pushvalue(luaState, lua_upvalueindex(1));
	output::printf(" (function) %s %p\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(luaState, -1)), RBX::FamilyGuy::lua::topointer(luaState, -1));
	RBX::FamilyGuy::lua::pushvalue(luaState, 1);
	output::printf("first arg (datamodel) %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(luaState, -1)));
	RBX::FamilyGuy::lua::pushvalue(luaState, 2);
	output::printf("second arg (index) %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(luaState, -1)));
	RBX::FamilyGuy::lua::pcall(luaState, 2, -1, 0);
	output::printf("done %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(luaState, -1)));

	return RBX::FamilyGuy::lua::gettop(luaState);
}

static void detourDatamodelJobStep(void* newStep, uintptr_t& oldStep)
{
	uintptr_t* job_ptr = RBX::FamilyGuy::getWaitingScriptsJob();

	if (job_ptr)
	{
		/* calculate size of the vtable */

		uintptr_t luaResumeWaitingScriptsJob = ida::get_string_address("LuaResumeWaitingScripts"); /* this is defined directly where the job's vtable ends */
		size_t vtable_sz = (luaResumeWaitingScriptsJob - *job_ptr) / sizeof(uintptr_t) ;

		/* get step func */

		uintptr_t step = static_addresses::getWaitingScriptsJobStepAddress();

		void** vtable = new void* [vtable_sz];
		memcpy(vtable, *reinterpret_cast<void***>(job_ptr), sizeof(void*) * vtable_sz);

		/* find step index */

		int step_index = 0; 
		for (int i = 0; i < vtable_sz; i++)
		{
			uintptr_t f = (uintptr_t)vtable[i];
			if (f == step)
			{
				step_index = i;
			}
		}

		if (step_index)
		{
			if (!oldStep)
				oldStep = step; /* last func, datamodeljobstep */

			vtable[step_index] = newStep;
			*reinterpret_cast<void***>(job_ptr) = vtable;

		}

		return;
	}
	output::printf("[error]: detourDatamodelJobStep() failed to detour! no WaitingScriptsJob\n");
}

static void detourDatamodelIndex()
{
	uintptr_t thread = RBX::FamilyGuy::getLuaState();

	RBX::FamilyGuy::lua::getfield(thread, LUA_GLOBALSINDEX, "game");
	output::printf("(game) top = %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(thread, -1)));
	RBX::FamilyGuy::lua::getmetatable(thread, -1);
	output::printf("(mt) top = %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(thread, -1)));

	RBX::FamilyGuy::lua::setreadonly(thread, -1, 0);

		RBX::FamilyGuy::lua::getfield(thread, -1, "__index");
		output::printf("(old index) top = %s, %p\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(thread, -1)), RBX::FamilyGuy::lua::topointer(thread, -1));
		RBX::FamilyGuy::lua::pushcclosure(thread, (int)newIndex, 1);
		output::printf("(newindex) top = %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(thread, -1)));
		RBX::FamilyGuy::lua::setfield(thread, -2, "__index");
		output::printf("(setfield) top = %s\n", RBX::FamilyGuy::lua::ttypename(0, RBX::FamilyGuy::lua::type(thread, -1)));

	RBX::FamilyGuy::lua::setreadonly(thread, -1, 1);

}

static void doDatamodelDetours()
{
	detourDatamodelIndex();
	detourDatamodelJobStep(newStep, oldStep);
}