#pragma once

#include <Windows.h>
#include <cstdint>
#include <string>

#include <intrin.h>
#include <vector>
#include <memory>
#include <functional>

#include "./util/retcheck.h"

extern "C"
{
	#include "lobject.h"
}

#define shift(x) (x- 0x400000 + reinterpret_cast<uintptr_t>(GetModuleHandle(0)))
#define prettify(x) (x + 0x400000 -  reinterpret_cast<uintptr_t>(GetModuleHandle(0)))
#define unretcheck(x) retcheckBypass(x)

#define RBX_ALIGN(s) _declspec(align(s)) 
typedef std::vector<std::shared_ptr<std::uintptr_t>> Instances;

class ProtectedString {

public:
	std::string source;
	std::string bytecode;
	ProtectedString(std::string str)
	{
		bytecode = str;
	}
	ProtectedString() { bytecode = ""; source = ""; }
};

class LuaSecureDouble
{
private:
	double storage;
public:
	static RBX_ALIGN(16) int luaXorMask[4];

	operator const double() const
	{
		return storage;
	}

	void operator=(const double& value)
	{
		__m128d xmmKey = _mm_load_pd((double*)(luaXorMask));
		__m128d xmmData = _mm_load_sd(&value);
		__m128d xmmResult = _mm_xor_pd(xmmData, xmmKey);
		storage = _mm_cvtsd_f64(xmmResult);
	}

	static void initDouble();

};

static double RBXNumber(double n)
{
	LuaSecureDouble d;
	d = n;
	return d;
}

// Utility class for obfuscating fields of primitive types
// WARNING: this will give incorrect results if T = float.
template <typename T> class LuaVMValue
{
public:
	operator const T() const
	{
		return (T)((uintptr_t)storage + reinterpret_cast<uintptr_t>(this));
	}

	void operator=(const T& value)
	{
		storage = (T)((uintptr_t)value - reinterpret_cast<uintptr_t>(this));
	}

	const T operator->() const
	{
		return operator const T();
	}

private:
	T storage;
};

typedef int(*r_luaC_function)(std::uintptr_t rL);

#define R_LUA_TLIGHTUSERDATA 1
#define R_LUA_TNUMBER 2
#define R_LUA_TBOOLEAN 3
#define R_LUA_TSTRING 4
#define R_LUA_TTHREAD 5
#define R_LUA_TFUNCTION 6
#define R_LUA_TTABLE 7
#define R_LUA_TUSERDATA 8
#define R_LUA_TPROTO 9
#define R_LUA_TUPVAL 10

static std::vector<const char*> r_luaT_typenames = { "nil", "pointer", "number", "bool", "string", "thread", "function", "table", "userdata", "proto", "upval" };

/*
static int rbx_type(std::uintptr_t rL, int idx)
{
	int t;
	TValue* r = (TValue*)(rbx_index2adr(rL, idx));

	if (r)
		t = r->tt;

	if (t == -1)
		t = 0;

	return t;
}
*/
